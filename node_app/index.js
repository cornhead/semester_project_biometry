#! /usr/bin/env node

// needed because app is of type 'module' 
import { createRequire } from "module";
const require = createRequire(import.meta.url);

import { program }  from 'commander';
import chalk from 'chalk';
import storage from 'node-persist';
import {performance} from 'perf_hooks';

const snarkjs = require("snarkjs");
import fs from 'fs';

/**
 * This is the (prime) order of the field over the BN128 elliptic curve
 */
const max_r = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

/**
 * Absolute path to the wasm file of the SNARK circuit (generated by SnarkJS)
 */
const wasm_file = import.meta.dirname + "/../circom_snarkjs_workdir/build/main_js/main.wasm";

storage.initSync();

program.version("1.0.0").description("A SNARK for proving matching finger vein patterns over committed data");

/**
 * Takes the path to a file and stores it in persistant storage as prover key 
 * @param {string} file_path - path to the prover key file
 */
async function set_zkey_file(file_path) {
    storage.setItem('zkey_file', file_path);

    console.log( "Setting zkey file to " + file_path);
    console.log( chalk.green("Success"));
}

/**
 * Takes the path to a file and stores it in persistant storage as verifier key 
 *
 * @param {string} file_path - path to the verifier key file
 */
async function set_vkey_file(file_path) {
    storage.setItem('vkey_file', file_path);

    console.log( "Setting vkey file to " + file_path);
    console.log( chalk.green("Success"));
}

/**
 * Prints the status of persistant storage.
 * That is, it prints all key-value pairs stored with node-persistant
 *
 * @return {void} returns nothing, prints to console
 */
async function status(){
    console.log(chalk.yellow("Storage Status:") + "The following values are stored in persistant storage:" );
    var keys = await storage.keys();
    for (var i = 0; i < keys.length; i += 1){
        console.log("\t"+keys[i]+"\t"+ await storage.getItem(keys[i]));
    }
}

/**
 * Takes the path to JSON file describing a test pattern (e.g. generated by the pattern generator),
 * parses it and returns a JSON object
 *
 * @param {string} file_path
 * @return {JSON} 
 */
async function load_testpattern_file(file_path){
    var f = fs.readFileSync(file_path, 'utf8');
    var pattern = JSON.parse(f);
    return pattern;
}

/**
 * Takes a test pattern and extracts the i-th test case from it
 *
 * @param {JSON} mypattern The test pattern as JSON object, e.g., obtained by {@link load_testpattern_file}
 * @param {int} i index of the test case to be extracted (i.e. zero-indexed) 
 * @return {JSON} the extracted test case
 */
async function extract_testcase_from_testpattern(mypattern, i){
    var model = mypattern.model;
    var probe = mypattern.probes[i];
    var miura = mypattern.miura[i];
    var convolution = mypattern.convolutions[i];

    return {
        "model" : model,
        "probe" : probe,
        "miura" : miura,
        "convolution" : convolution
    };
}

/**
 * Takes the path to a JSON file describing a test pattern and executes all contained test cases
 *
 * For each test case, the public output of the circuit checked against the
 * expected value (with a small error tolerance defined by EPSILON) and the time
 * for proof generation and verification is measured. In the end, the average
 * prover and verifier time is computed.
 * 
 * If all test cases passed, the average execution times are printed.
 * Otherwise, an according error report is printed.
 *
 * If a generated proof fails to be verified, this is considered a fatal
 * error and the further execution is aborted.
 *
 * @param {string} file_path - path to the JSON file describing a test pattern
 */
async function test(file_path){
    const EPSILON = 0.000001;

    var pattern = await load_testpattern_file(file_path);
    var len = pattern.probes.length;

    var testcases_failed = 0;
    var prover_times = [];
    var verifier_times = [];
    
    for (var i = 0; i < len; i += 1){
        process.stdout.write("Running test case " + (i+1) + "/" + len + "...\r");

        var testcase = await extract_testcase_from_testpattern(pattern, i);

        // Sample random field elements for commitments
        var r_model = Math.floor(Math.random() * max_r);
        // var r_probe = Math.floor(Math.random() * max_r);

        var input_json = {
            "model": testcase.model,
            "probe": testcase.probe,
            "r_model": r_model,
            // "r_probe" : r_probe
        };

        // Generate Witness + Proof (aka full proof)

        var resP = await prove_internal(input_json);
        var ps = resP.public_signals;
        prover_times.push(resP.prover_time);

        // Extract public values from circuit output

        var num = ps[1];
        var den = ps[2];
        var miura = num/den;

        var convolution = resP.public_signals.slice(3); 

        // Check if computed Miura score matched expected value

        if (Math.abs(miura-testcase.miura) > EPSILON) {
            testcases_failed += 1;

            console.log(chalk.red("Testcase Failed: "));
            console.log("\tTest case ", (i+1), "/", len, " failed because the Miura score was incorrect.");
            console.log("\tExpected ", testcase.miura, ", got ", num, "/", den, "=", miura);

            continue;
        }

        // Check that convolution is correct
        
        if (convolution.length != testcase.convolution.length){
            testcases_failed += 1;

            console.log(chalk.red("Testcase Failed: "));
            console.log("\tTest case ", (i+1), "/", len, " failed because the length of the convolution did not match the expected length.");
            console.log("\tExpected ", testcase.convolution.length, ", got ", convolution.length);

            continue;
        }

        for (var i = 0; i < convolution.length; i += 1){
            if (convolution[i] != testcase.convolution[i]){
                testcases_failed += 1;

                console.log(chalk.red("Testcase Failed: "));
                console.log("\tTest case ", (i+1), "/", len, " failed because the convolution is incorrect at index ", i, ".");
                console.log("\tExpected ", testcase.convolution[i], ", got ", convolution[i]);

                continue;
            }
        }


        // Verify proof

        var resV = await verify_internal(resP.proof, resP.public_signals);
        verifier_times.push(resV.verifier_time);

        if (!resV.accept){
            console.log(chalk.red("FATAL ERROR:"));
            console.log("\tTest case ", (i+1), "/", len, " failed because the verifier did not accept the proof by the prover.");
            console.log("\t", resP.proof);

            process.exit(1);
        }

    }

    console.log(); // needed to go to next line after carriage return for progress indicator

    if (testcases_failed == 0){
        console.log(chalk.green("ALL TEST CASES PASSED"));
        
        var avg_prover_time = prover_times.reduce( (a,b) => a+b, 0) / len;
        var avg_verifier_time = verifier_times.reduce( (a,b) => a+b, 0) / len;
        console.log("Avg. prover time:   ", avg_prover_time, "ms");
        console.log("Avg. verifier time: ", avg_verifier_time, "ms");
    }
    else {
        console.log(chalk.red(testcases_failed, "/", len, " TEST CASES FAILED"));
    }

    process.exit( testcases_failed == 0 ? 1 : 0 );
}

/**
 * Takes a JSON object describing the inputs to the circuit of the SNARK
 * and computes the witness (remaining wire values) and a proof.
 * While doing so, the prover time is measured.
 * In the end, the proof, the public outputs of the circuit and
 * the prover time are returned as a JSON object
 *
 * @param {JSON} input - A JSON object defining the input to the circuit
 * @returns {JSON} A JSON object with the public output of the circuit, the proof and the prover time
 */
async function prove_internal(input_json){
    var zkey_file = await storage.getItem('zkey_file');
    if (zkey_file == undefined){
        console.log(chalk.red("Error:") + "You first have to set a zkey file.");
        process.exit(1);
    }

    const t0 = performance.now(); // https://developer.mozilla.org/en-US/docs/Web/API/Performance/now
    const { proof, publicSignals } = await snarkjs.groth16.fullProve( input_json, wasm_file, zkey_file);
    const t1 = performance.now();
    const prover_time = t1-t0;

    return {
        "proof" : proof,
        "public_signals" : publicSignals,
        "prover_time" : prover_time
    };
}

/**
 * Takes a path to a JSON file defining the inputs to the circuit and generates a proof and
 * computes the public output of the circuit. A message is printed giving the proof, the
 * public values and the prover time.
 *
 * The differences to {@link prove_internal} are that the input is read from a file instead
 * of a JSON object, and that it doesn't return but prints the values to the console.
 * In fact, this function is just a wrapper around {@link prove_internal}.
 *
 * @param {string} file_path - The path to the JSON file defining the inputs to the circuit
 */
async function prove(file_path) {
    var f = fs.readFileSync(file_path, 'utf8');
    var input_json = JSON.parse(f);

    var res = await prove_internal(input_json);

    console.log(chalk.green("Public Signals: "), JSON.stringify(res.public_signals));
    console.log(chalk.green("Proof: "), JSON.stringify(res.proof));
    console.log(chalk.green("Success"), "(Prover Time ", res.prover_time/1000, " sec.)");
    
    process.exit(0);
}

/**
 * Takes a proof as JSON object and public signals of a circuit and verifies the validity of the proof.
 * Verification time is measured and returned together with the result of the verification.
 *
 * @param {JSON} proof - the proof
 * @param {JSON} public_signals - the public signals (input and output) of the circuit
 * @returns {JSON} An object with the verification time and the result of the verification
 */
async function verify_internal(proof, public_signals) {
    var vkey_file = await storage.getItem('vkey_file');
    if (vkey_file == undefined){
        console.log(chalk.red("Error: ") + "You first have to set a vkey file.");
        process.exit(1);
    }

    var vkey_path = await storage.getItem("vkey_file");
    const vKey = JSON.parse(fs.readFileSync(vkey_path));

    const t0 = performance.now();
    const res = await snarkjs.groth16.verify(vKey, public_signals, proof);
    const t1 = performance.now();
    const verifier_time = t1-t0;

    return {
        "accept" : (res === true),
        "verifier_time" : verifier_time
    };
}

/**
 * Takes a proof and public inputs of a circuit as strings and verifies the validity of
 * the proof with respect to the inputs and the circuit.
 * The result of the verification, together with the measured verification time,
 * is printed to the consoles printed to the console.
 *
 * In constrast to {@link verify_internal}, the inputs are not given as JSON objects
 * but as string-representations thereof. Furthermore, the results are not returned
 * but rather printed to the screen. This function is a wrapper of {@link verify_internal}
 * that provides an interface for the user to the internal function. The relation
 * between {@link verify} and {@link verify_internal} is the same as between
 * {@link prove} and {@link prove_internal}.
 *
 * @param {string} proof_str - string representation of a proof
 * @param {string} public_signals_str - string representation of the public signals of the circuit
 */
async function verify(proof_str, public_signals_str){
    var proof = JSON.parse(proof_str);
    var public_signals = JSON.parse(public_signals_str);

    var res = await verify_internal(proof, public_signals);

    if (res.accept) {
        console.log(chalk.green("Verification OK"), "(Verifier Time: ", res.verifier_time/1000," sec.)");
        console.log(chalk.green("Miura Score: ") + public_signals[2]/public_signals[3]);
        process.exit(0);
    } else {
        console.log(chalk.red("Invalid proof"));
        process.exit(1);
    }
}

program
    .command('set_zkey_file <file>')
    .description('Takes a path to the zkey file (circuit specific)')
    .action((file) => set_zkey_file(file))

program
    .command('set_vkey_file <file>')
    .description('Takes a path to the verification key file (circuit specific)')
    .action((file) => set_vkey_file(file))

program
    .command('prove <file>')
    .description('Takes a JSON file with the input parameters to the circuit, computes the output of the circuit and provides a proof of correctness')
    .action((input) => prove(input))

program
    .command('test <file>')
    .description('Takes the path to a JSON file with test patterns and performs tests and benchmarkings')
    .action((file) => test(file))

program
    .command('verify <proof> <publicSignals>')
    .description('takes a proof and public signals as stringified JSON objects and verifies the SNARK')
    .action((proof, publicSignals) => verify(proof, publicSignals))

program
    .command('status')
    .description('Prints the status of the persitant storage (e.g. file paths to prover and verifier keys)')
    .action((proof, publicSignals) => status())

program.parse()
